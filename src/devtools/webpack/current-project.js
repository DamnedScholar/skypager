/**
 * Provides metadata about the current project
 */
const paths = require('./config/paths')

// This will always be in the context of the nearest package.json in process.cwd()
const runtime = require('@skypager/node')

const projectTypes = {}

const { mapValues, keys, uniq, isArray, isString } = runtime.lodash
const { gitInfo, currentPackage, fileManager } = runtime
const { devDependencies = {}, dependencies = {}, peerDependencies = {} } = currentPackage

const dependsOnSkypagerPackages = uniq(
  [...keys(devDependencies), ...keys(dependencies), ...keys(peerDependencies)].filter(name =>
    name.startsWith('@skypager')
  )
)

// only generate this once
let buildSummary

/**
 * @typedef {Object} SkypagerDependencies
 * @property {Array<String>} features the name of the features this project depends on
 * @property {Array<String>} helpers the name of the helpers this project depends on
 * @property {Array<String>} runtimes the name of the runtimes this project depends on
 * @property {Object<String,String>} versions the versions of the packages that are depended on
 */
const skypagerDependencies = {
  features: dependsOnSkypagerPackages.filter(name => name.startsWith('@skypager/features')),
  helpers: dependsOnSkypagerPackages.filter(name => name.startsWith('@skypager/helpers')),
  runtimes: dependsOnSkypagerPackages.filter(
    name =>
      name.startsWith('@skypager/runtimes') ||
      name === '@skypager/web' ||
      name === '@skypager/react'
  ),
}

skypagerDependencies.versions = buildVersionsMap(skypagerDependencies)

/**
 * Provides current info about the state of the git tree
 *
 * @typedef {Object} GitInfo
 * @property {String} branch
 * @property {String} sha
 * @property {String} abbreviatedSha
 */

/**
 * Represents a file generated by the build
 *
 * @typedef {Object} BuildArtifact
 * @property {Number} size
 * @property {String} name
 * @property {String} hash
 * @property {String} mimeType
 */

/**
 * Provides information about all of the build artifacts, and the state of the source in the project which produced it
 *
 * @typedef {Object} BuildSummary
 * @property {String} buildHash a composite md5 hash of all of the build artifacts
 * @property {String} sourceHash a composite md5 hash of all of the source code in the project
 * @property {String} version the version at the time of building
 * @property {String} cacheKey a unique identifier for the build summary
 * @property {Number} count the number of build artifacts
 * @property {Number} maxUpdatedAt the maximum updated at time of the build artifact
 * @property {Array<BuildArtifact>} outputFiles
 */

/**
 * This module can be required by any build / server script and have a bunch of useful information
 * about the current project and its dependencies
 *
 * @typedef {Object} CurrentProject
 * @property {String} name
 * @property {String} version
 * @property {GitInfo} gitInfo
 * @property {Object<String,String>} paths
 * @property {Function} sourceHash
 * @property {Function} buildSummary
 * @property {Function} buildHash
 * @property {Function} checkForExistingBuild
 * @property {Array<String>} htmlTemplates
 * @property {Object} config
 * @property {Object} releaseEnvironmentVariables
 * @property {Object} argv
 * @property {Boolean} isCI
 * @property {Object} currentModule
 * @property {SkypagerDependencies} skypagerDependencies
 */

const isCI = process.env.CI || (process.env.JOB_NAME && process.env.JOB_NUMBER)

if (isCI && !process.env.CI) {
  process.env.CI = 'TRUE'
}

const config = Object.assign(
  {},
  currentPackage.skypager || {},
  (currentPackage.skypager && currentPackage.skypager.webpack) || {},
  runtime.argv
)
/**
 * @type {CurrentProject}
 */
const currentProject = Object.assign({}, currentPackage.skypager || {}, {
  runtime,

  name: currentPackage.name,

  version: currentPackage.version,

  gitInfo,

  portfolioRoot: gitInfo.root,

  paths,

  isCI,

  /** Whatever the current project has in its skypager property */
  config,

  argv: runtime.argv,

  /**
   * Returns true if the project has any modified or unstaged files.
   */
  get isDirty() {
    return runtime.git.isDirty
  },

  /**
   * Returns the html template files that exist within the current project
   */
  get htmlTemplates() {
    if (!runtime.fsx.existsSync(paths.appPublic)) {
      return []
    }

    const htmlFiles = runtime.fsx
      .readdirSync(paths.appPublic)
      .filter(filename => filename.startsWith('index') && filename.endsWith('.html'))
    return htmlFiles.map(filename => runtime.resolve(paths.appPublic, filename))
  },

  /**
   * Returns a module from the require cache that will be in the current folder of the current project.
   * This gets used by the Plug n Play module loader in the webpack config
   */
  get currentModule() {
    require(runtime.resolve('package.json'))
    return require.cache[runtime.resolve('package.json')]
  },

  /**
   * Used in webpack output configuration
   */
  get libraryTarget() {
    if (runtime.argv.libraryTarget) {
      return runtime.argv.libraryTarget
    }

    return this.config.libraryTarget || 'umd'
  },

  get libraryName() {
    if (runtime.argv.libraryName) {
      return runtime.argv.libraryName
    }

    const { name } = this
    const { libraryName } = this.config
    const { upperFirst, camelCase } = runtime.stringUtils

    if (libraryName && libraryName.length) {
      return libraryName
    }

    return upperFirst(camelCase(name.split('/').pop()))
  },

  resolve(...args) {
    return runtime.resolve(...args)
  },

  resolvePortfolioPath(...args) {
    return runtime.resolve(this.portfolioRoot, ...args)
  },

  resolveCachePath(...args) {
    return runtime.resolve(this.cacheRoot, ...args)
  },

  get cacheRoot() {
    let { cacheRoot = process.env.PORTFOLIO_CACHE_DIRECTORY } = runtime.argv

    return (
      cacheRoot ||
      (isCI
        ? runtime.resolve(runtime.os.os.homedir(), '.skypager', 'cache')
        : runtime.resolve(this.portfolioRoot, 'node_modules', '.cache', 'skypager'))
    )
  },

  resolveAll(paths) {
    if (isArray(paths)) {
      return paths.map(p => runtime.resolve(...p.split('/')))
    } else if (isString(paths)) {
      return runtime.resolve(...paths.split('/'))
    }
  },

  /**
   * Returns ENV variables that should be injected into the build
   * via the config/env.js which gets fed into InterpolateHtmlWebpackPlugin
   */
  get releaseEnvironmentVariables() {
    const { projectType } = this.config

    let projectSpecificVariables = {}

    return {
      ...projectSpecificVariables,
      RELEASE_PACKAGE_NAME: currentPackage.name,
      RELEASE_VERSION: currentPackage.version,
      GIT_SHA: gitInfo.abbreviatedSha,
      GIT_BRANCH: gitInfo.branch,
    }
  },
  /**
   * Returns a composite md5 hash of the project's src files, based on what is in the current project
   * that is not git ignored.  The value will always be the same until there is any change made to any files that aren't git ignored (regardless,
   * if they've been staged or commited.)  This is more reliable than git SHA for local development.
   */
  async sourceHash(options) {
    const { sourceHash } = await this.buildSummary(options)
    return sourceHash
  },

  /**
   * Returns a composite md5 hash of all of the project's built files.  For any given source hash, there will be another build hash.  After running
   * a build, saving the source hash and build hash together can be used as a way of determining of a particular build folder is behind what
   * it needs to be.
   */
  async buildHash(options) {
    const { buildHash } = await this.buildSummary(options)
    return buildHash
  },

  /**
   * Returns a summary about the project's source / git status and build output
   *
   * @param {Object} options
   * @param {String} baseFolder the absolute path to the build folder
   * @param {Array<String>} exclude an array of paths to exclude
   * @returns {Promise<BuildSummary>}
   */
  async buildSummary(options) {
    if (buildSummary) {
      return buildSummary
    }

    await runtime.fileManager.startAsync(options)

    buildSummary = await runtime.fileManager.hashBuildTree({
      baseFolder: this.paths.appBuild,
      files: [this.resolvePortfolioPath('yarn.lock')],
    })

    return buildSummary
  },

  /**
   * Returns true if the project requires the build process to move forward.
   *
   * Will return false in the cases where the sourceHash of the currentProject is equal to
   * the sourceHash generated in the previous build cycle.
   *
   * @returns {Promise<Boolean>}
   */
  async checkForExistingBuild() {
    if (runtime.argv.force) {
      return true
    }

    const infoFile = runtime.resolve(paths.appBuild, 'build-manifest.json')
    const infoExists = await runtime.fsx.existsAsync(infoFile)

    if (!infoExists) {
      return true
    }

    const previousBuild = await runtime.fsx.readJsonAsync(infoFile).catch(() => ({}))
    const summary = await this.buildSummary()

    return previousBuild.sourceHash !== summary.sourceHash
  },

  async saveBuildSummary(data = {}) {
    let summary = await (buildSummary || this.buildSummary())

    const infoFile = runtime.resolve(paths.appBuild, 'build-manifest.json')

    await runtime.fsx.writeFileAsync(
      infoFile,
      JSON.stringify(
        {
          ...summary,
          ...data,
        },
        null,
        2
      )
    )

    return summary
  },

  get cdnLocation() {
    const { name, version } = runtime.currentPackage
    const baseUrl = `https://cdn.skypager.io/${name}/${version}`
    return baseUrl
  },

  get distPaths() {
    const { currentPackage } = runtime

    const browser = String(currentPackage.browser)
      .replace(/^\.\//, '')
      .replace(/^(build|lib)\//, '')
    const style = String(currentPackage.style)
      .replace(/^\.\//, '')
      .replace(/^(build|lib)\//, '')

    return {
      ...(currentPackage.browser && { browser }),
      ...(currentPackage.style && { style }),
    }
  },

  get projectTypeHooks() {
    const { mapValues } = runtime.lodash
    const { projectType } = this.config

    const hooks = runtime.lodash.defaults({}, projectTypes[projectType], {
      beforeBuild: async () => true,
    })

    return mapValues(hooks, fn => fn.bind(this))
  },

  checkCache() {
    return runtime.argv.resetCache ? resetCache() : true
  },

  printHeader() {},

  printHostingInstructions(appPackage, publicUrl, publicPath, buildFolder, useYarn) {
    const { randomBanner, print, colors } = runtime.cli

    randomBanner(appPackage.name.replace('@skypager/', '').replace(/^(apps|helpers|features)-/, ''))

    print(
      `Build Complete. Version ${colors.bold.magenta(appPackage.version)} SHA ${colors.bold.cyan(
        this.gitInfo.abbreviatedSha
      )}`,
      0,
      2
    )
    const deployTo = (this.config.deployTo || []).map(target => String(target).toLowerCase())

    if (!deployTo.length) {
      return
    }

    console.log('\n\n')
  },

  externals: target => {
    const ext = config[target] ? config[target].externals || config.externals : config.externals

    return (
      ext &&
      Object.values(
        mapValues(ext || {}, (varName, modName) =>
          toExternal(modName, varName, currentProject.libraryTarget)
        )
      ).reduce((memo, h) => ({ ...memo, ...h }), {})
    )
  },
  /**
   * @type {SkypagerDependencies}
   */
  skypagerDependencies,
})

function buildVersionsMap(dependencies = {}) {
  const { values, flatten, omitBy } = runtime.lodash

  const versions = flatten(values(dependencies)).reduce(
    (memo, pkg) => ({
      ...memo,
      [pkg]: checkVersion(pkg),
    }),
    {}
  )

  return omitBy(versions, v => !v)
}

function checkVersion(packageName) {
  try {
    return require(`${packageName}/package.json`).version
  } catch (error) {
    return false
  }
}

module.exports = currentProject

async function resetCache() {
  const {
    babelCacheDirectory,
    terserCacheDirectory,
    hardSourceCacheDirectory,
  } = require('./config/flags')(currentProject, true)

  await Promise.all([
    runtime.fsx.removeAsync(babelCacheDirectory).catch(e => {}),
    runtime.fsx.removeAsync(terserCacheDirectory).catch(e => {}),
    runtime.fsx.removeAsync(hardSourceCacheDirectory.replace('/[confighash]', '')).catch(e => {}),
  ])

  return true
}

function toExternal(moduleName, varName, libraryTarget) {
  if (libraryTarget === 'umd') {
    return {
      [moduleName]: {
        commonjs: moduleName,
        commonjs2: moduleName,
        amd: moduleName,
        root: `${varName}`,
      },
    }
  } else {
    return { [moduleName]: `global ${varName}` }
  }
}
